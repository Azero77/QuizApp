<MudPaper Class="ma-3 mx-auto" Style="max-width: 100vh;"
          dir="rtl">
    <!-- Flex layout for question number + text -->
    <MudStack Row="true" Justify="Justify.FlexStart" Class="mb-4">
        <MudText Typo="Typo.inherit" Color="Color.Primary" Class="me-2">
            @QuestionNumber.
        </MudText>
        <MudText Typo="Typo.h4">
            @foreach (var segment in Question.QuestionText)
            {
                @RenderQuestionSegment(segment)
            }
        </MudText>
    </MudStack>

    <!-- Choices as selectable list items -->
    <MudList @bind-SelectedValue="SelectedIndex"
             SelectionMode="SelectionMode.SingleSelection"
             T="int"
             Color="@Color.Info"
             Dense="true" Hover="true"
             >
        @for (int i = 0; i < Question.QuestionChoices.Count; i++)
        {
            var choice = Question.QuestionChoices[i];
            var prefix = GetChoicePrefix(i); // Get the prefix (A, B, C, ...)

            <MudListItem Class="d-flex align-items-center question-choice"
                         Value="i"
                         Disabled = "Corrected"
                         Style="cursor: pointer;">
                <!-- Render the prefix and the choice -->
                <div class="question-choice">
                    <MudStack Row="true" Gap="Gap.Small">
                        <MudText Typo="Typo.body1" Color="Color.Primary">
                            @prefix.
                        </MudText>
                        <MudStack Row="true">
                            @foreach (var segment in choice)
                            {
                                @RenderQuestionSegment(segment)
                            }
                        </MudStack>
                    </MudStack>
                </div>
            </MudListItem>
        }
    </MudList>
</MudPaper>

@code {
    [Parameter]
    public Question Question { get; set; } = null!;

    [Parameter]
    public int QuestionNumber { get; set; }

    [CascadingParameter]
    public bool Corrected { get; set; }


    private int _selectedIndex = -1; // Backing field for SelectedIndex
    public int SelectedIndex
    {
        get => _selectedIndex;
        set
        {
            if (_selectedIndex != value)
            {
                _selectedIndex = value;
                OnChoiceSelected(value); // Call the method when the value changes
            }
        }
    }
    private void OnChoiceSelected(int selectedIndex)
    {
        // Convert the selected index to A, B, C format
        var selectedChoiceLetter = GetChoicePrefix(selectedIndex);
        QuestionSelected(QuestionNumber,selectedChoiceLetter);
    }

    private string GetChoicePrefix(int index)
    {
        // Convert the index to a corresponding letter (0 → A, 1 → B, 2 → C, etc.)
        return ((char)('A' + index)).ToString();
    }

    private bool IsArabic(List<QuestionSentence> questionText)
    {
        if (questionText == null || !questionText.Any())
            return false;

        // Check if any segment contains Arabic text
        return questionText.Any(segment =>
            segment.Text.Any(c => c >= 0x0600 && c <= 0x06FF));
    }

    private string GetChoiceText(List<QuestionSentence> choice)
    {
        // Concatenate all segments in the choice to form a single string
        return string.Join(" ", choice.Select(segment => segment.Text));
    }

    private RenderFragment RenderQuestionSegment(QuestionSentence segment) => builder =>
    {
        switch (segment.QuestionSentenceType)
        {
            case QuestionSentenceType.SimpleText:
                builder.AddContent(0, segment.Text);
                break;

            case QuestionSentenceType.ParagraphEquation:
                builder.OpenElement(1, "div");
                builder.AddAttribute(2, "class", "text-center"); // Add text-center class
                builder.AddContent(3, RenderEquation(segment.Text));
                builder.CloseElement();
                break;

            case QuestionSentenceType.InlineEquation:
                builder.OpenElement(4, "span");
                builder.AddContent(5, RenderEquation(segment.Text));
                builder.CloseElement();
                break;

            case QuestionSentenceType.ImageUrl:
                builder.OpenElement(6, "img");
                builder.AddAttribute(7, "src", segment.Text);
                builder.AddAttribute(8, "alt", segment.AltText ?? "Image");
                builder.CloseElement();
                break;

            case QuestionSentenceType.CodeBlock:
                builder.OpenElement(9, "pre");
                builder.AddContent(10, segment.Text);
                builder.CloseElement();
                break;

            case QuestionSentenceType.Table:
                builder.OpenElement(11, "table");
                builder.AddMarkupContent(12, segment.Text); // Assuming Text contains HTML table markup
                builder.CloseElement();
                break;

            default:
                builder.AddContent(13, segment.Text);
                break;
        }
    };

    [Parameter]
    [EditorRequired]
    public Action<int, string> QuestionSelected { get; set; } = null!;

    private RenderFragment RenderEquation(string equation) => builder =>
    {
        // Render equation using a library like MathJax or KaTeX
        builder.OpenElement(13, "span");
        builder.AddAttribute(14, "class", "math-equation");
        builder.AddContent(15, equation);
        builder.CloseElement();
    };
}